#!/usr/bin/env python33
# coding=utf-8
#
# Copyright (c) 2010-2015 Illumina, Inc.
# All rights reserved.
#
# This file is distributed under the simplified BSD license.
# The full text can be found here (and in LICENSE.txt in the root folder of
# this distribution):
#
# https://github.com/Illumina/licenses/blob/master/Simplified-BSD-License.txt

import os
import subprocess
import logging
import pandas
import tempfile
import gzip
import pipes
from typing import List, Tuple, Optional, Dict, Any, Union

import Tools


scriptDir = os.path.abspath(os.path.dirname(__file__))


def runShellCommand(*args) -> Tuple[str, str, int]:
    """ Run a shell command (e.g. bcf tools), and return output

    Args:
        *args: Command and arguments to run

    Returns:
        Tuple of (stdout, stderr, return_code)

    Raises:
        Exception: If the command returns a non-zero exit code
    """
    qargs = []
    for a in args:
        if a.strip() != "|":
            qargs.append(pipes.quote(a))
        else:
            qargs.append("|")

    cmd_line = " ".join(qargs)
    logging.info(cmd_line)

    po = subprocess.Popen(cmd_line,
                          shell=True,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          universal_newlines=True)  # text mode output

    stdout, stderr = po.communicate()

    po.wait()

    return_code = po.returncode

    if return_code != 0:
        logging.error("Failed to run command %s" % cmd_line)
        logging.error("stderr: %s" % stderr)
        logging.error("stdout: %s" % stdout)
        raise Exception("Failed to run command %s" % cmd_line)

    return stdout, stderr, return_code


def runBcftools(*args) -> Tuple[str, str, int]:
    """ Run BCF tools

    Args:
        *args: Arguments for bcftools

    Returns:
        Tuple of (stdout, stderr, return_code)
    """
    return runShellCommand("bcftools", *args)


def runBcftoolsView(*args) -> Tuple[str, str, int]:
    """ Run BCF tools view

    Args:
        *args: Arguments for bcftools view

    Returns:
        Tuple of (stdout, stderr, return_code)
    """
    newargs = ["view"]
    newargs.extend(args)
    return runBcftools(*newargs)


def getHeader(filename: str) -> List[str]:
    """ Return VCF header as a list of strings

    Args:
        filename: VCF filename

    Returns:
        List of header lines
    """
    if not os.path.exists(filename):
        raise Exception("File not found: %s" % filename)

    for f in [filename + ".tbi", filename + ".csi"]:
        if not os.path.exists(f):
            logging.info("Running tabix/bcftools on %s" % filename)
            # generate index
            try:
                stdout, stderr, ret = runShellCommand("tabix", "-p", "vcf", filename)
                break
            except Exception:
                try:
                    stdout, stderr, ret = runShellCommand("bcftools", "index", "-f", filename)
                    break
                except:
                    logging.warn("Failed to tabix %s" % filename)

    header_line = []

    try:
        stdout, stderr, ret = runBcftoolsView("-h", filename)
    except Exception as e:
        logging.error("Cannot process file %s" % filename)
        raise e

    for line in stdout.splitlines():
        if not line.strip():
            continue
        header_line.append(line)

    return header_line


def getHeaderAndVariants(filename: str) -> Tuple[List[str], List[List[str]]]:
    """ Read variants into a variant list

    Args:
        filename: VCF filename

    Returns:
        Tuple of (header lines, variant records)
    """

    header_line = []
    allvariants = []

    try:
        stdout, stderr, ret = runBcftoolsView(filename)
    except Exception as e:
        logging.error("Cannot process file %s" % filename)
        raise e

    for line in stdout.splitlines():
        if not line.strip():
            continue

        if line.startswith("#"):
            header_line.append(line)
            continue

        rec = line.split("\t")

        if len(rec) < 8:
            continue

        allvariants.append(rec)

    return header_line, allvariants


def getGA4GHVariants(filename: str, regions: Optional[str] = None) -> List[Dict[str, Any]]:
    """ Get variant list from pyvcf

    Args:
        filename: VCF filename
        regions: Optional regions to restrict to

    Returns:
        List of variant records
    """
    from vcf.parser import _Parse
    import vcf

    if not os.path.exists(filename):
        raise Exception("File not found: %s" % filename)

    reader = vcf.Reader(filename=filename)

    # Determining sample list here
    samples = reader.samples
    logging.info("Using samples %s" % str(samples))

    if len(samples) == 0:
        raise Exception("No samples in VCF.")

    result = []
    region_index = 0
    region_count = 0

    def addVar(record):
        # TODO check if variant normalisation works as advertised
        if len(record.REF) > len(record.ALT) and len(record.ALT[0]) > 0 and len(record.REF) > 1:
            # This looks like a deletion
            record.REF = record.REF[0:len(record.ALT[0])] + record.REF[len(record.ALT[0]):]
            record.ALT[0] = record.ALT[0][0:1]
            record.POS += (len(record.ALT[0]) - 1)
        varinfo = {
            "reference": record.REF,
            "position": record.POS,
            "info": dict(record.INFO),
            "id": record.ID,
            "quality": record.QUAL,
            "filter": record.FILTER,
            "calls": []
        }

        # TODO check if this is the right thing to do with record.ALT
        if len(record.ALT) == 0 or record.ALT[0] is None:
            varinfo["alternates"] = ["N"]
        else:
            varinfo["alternates"] = [a for a in record.ALT]

        for c in record.samples:
            # TODO this needs to be changed if we want to use this for true multiallelic variants
            call = {"genotype": [] if c.gt_alleles is None else c.gt_alleles, "phaseset": c.phased}
            for x in dir(c.data):
                if x.startswith("_"):
                    continue
                if x == "GT":
                    continue
                val = getattr(c.data, x, None)

                if val is None:
                    call[x.lower()] = None
                else:
                    if isinstance(val, list):
                        if x in ["AD", "PL"]:
                            val = list(map(int, val))
                        else:
                            val = list(map(float, val))
                    elif x == "GQ":
                        val = int(val)
                    else:
                        # TODO problematic if we need integers here
                        val = float(val)

                    call[x.lower()] = val

            varinfo["calls"].append(call)

        varinfo["samples"] = samples
        varinfo["contig"] = record.CHROM

        return varinfo

    # read regional data
    if regions is not None:
        reader2 = vcf.Reader(filename=filename)
        regs = regions.split(",")
        region_count = len(regs)
        for r in regs:
            region_index += 1
            logging.info("%i / %i : Processing region %s" % (region_index, region_count, r))
            try:
                for record in reader2.fetch(r):
                    result.append(addVar(record))
            except ValueError:
                logging.warn("No variants in region %s" % r)
    else:
        # read all data
        for record in reader:
            result.append(addVar(record))

    return result
